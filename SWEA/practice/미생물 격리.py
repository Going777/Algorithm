'''
약품 칠해진 셀(테두리)에 도착하면 미생물 절반으로 줄어듬 & 이동방향 반대로
    ㄴ 미생물 수가 홀수면, 미생물 수를 2로 나누고 소수점 버림
    ㄴ 미생물이 한 마리 있다면 > 군집이 사라짐
이동 후 두개의 군집이 한 셀에 모이면 군집들이 합쳐짐 & 이동방향은 미생물 수가 많은 군집 방향으로
M시간 후 남아있는 미생물 수 총합은?
'''
r_dir = [0,2,1,4,3]
di = [0,-1,1,0,0]
dj = [0,0,0,-1,1]

T = int(input())
for tc in range(1, T+1):
    N, M, K = map(int, input().split())     # N: 행렬 크기 / M: 격리 시간 / K: 미생물 군집 수
    arr = [list(map(int, input().split())) for _ in range(K)]

    for _ in range(M):  # M회 만큼 이동
        for i in range(len(arr)):
            # 1칸 이동처리
            # [0]은 i좌표 / [1]은 j좌표 / [2]는 미생물 수 / [3]은 방향
            arr[i][0] = arr[i][0]+di[arr[i][3]]
            arr[i][1] = arr[i][1]+dj[arr[i][3]]

            # 이동한 좌표가 경계인 경우 처리
            if arr[i][0] in [0, N-1] or arr[i][1] in [0, N-1]:
                arr[i][2] //= 2                 # 미생물 수 절반으로
                arr[i][3] = r_dir[arr[i][3]]    # 방향 반대로

        # 같은 좌표 처리 (위쪽 큰 미생물과 합치고, 방향 찾기)
        arr.sort(key=lambda x: (x[0], x[1], x[2]), reverse=True)  # 같은 좌표가 나란히 위치 & 미생물 수는 더 많은게 먼저 오도록 조작
        i = 1
        while i < len(arr): # pop을 사용할 것이기 때문에 length 사용!!!
            # 같은 경우 합치고 본인은 제거
            if arr[i-1][0:2] == arr[i][0:2]:
                arr[i-1][2] += arr[i][2]
                arr.pop(i)
            # 다르다면 밑으로 내려가서 다시 비교
            else:
                i += 1

    # 남아있는 미생물 수 모두 더하기
    ans = 0
    for lst in arr:
        ans += lst[2]

    print(f'#{tc} {ans}')


'''
1
7 2 9
1 1 7 1
2 1 7 1
5 1 5 4
3 2 8 4
4 3 14 1
3 4 3 3
1 5 8 2
3 5 100 1
5 5 1 1

1
10 17 46
7 5 724 2
7 7 464 3
2 2 827 2
2 4 942 4
4 5 604 4
7 2 382 1
6 5 895 3
8 7 538 4
6 1 299 4
4 7 811 4
3 6 664 2
6 8 868 2
7 6 859 2
4 6 778 2
5 4 842 3
1 3 942 1
1 1 805 3
3 2 350 3
2 5 623 2
5 3 840 1
7 1 308 4
1 8 323 3
2 3 82 3
2 6 115 2
8 3 930 1
6 2 72 1
2 1 290 3
4 8 574 4
8 5 150 3
8 2 287 2
2 8 909 2
2 7 588 2
7 3 30 3
5 8 655 3
3 8 537 1
4 2 350 3
5 6 199 1
5 5 734 2
3 3 788 1
8 4 893 1
1 4 421 4
6 3 616 2
1 2 556 4
7 8 8 1
5 2 702 2
4 4 503 3
'''